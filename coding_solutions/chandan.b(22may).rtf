{\rtf1\ansi\ansicpg1252\cocoartf2511
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;\red62\green0\blue63;\red255\green255\blue255;\red26\green26\blue26;
}
{\*\expandedcolortbl;;\cssrgb\c31373\c0\c31373;\cssrgb\c100000\c100000\c100000;\cssrgb\c13333\c13333\c13333;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl220\sa200\partightenfactor0

\f0\fs20 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Hint:\cb1 \uc0\u8232 \cb3 First Create a Singly Linked List Stack with the node corresponding to First Element is the base of the stack; and its link field must be always Null.\cb1 \uc0\u8232 \cb3 When you push First Element, It is the First and it is Base of the stack. Its Link must be Null. top pointer pointing to First. (top = First)\cb1 \uc0\u8232 \cb3 When you push any element, (No need of checking Stack full case because SLL is dynamic) Create a new node called temp using malloc function and insert the a number into Data field, and Link field must be pointing to top; and move the pointer top to point to temp.\cb1 \uc0\u8232 \cb3 When you pop, First check for stack Empty. if First == NULL, then Stack Empty. If it is not empty, The pointer temp must be pointing to top. Move the pointer top to top->link. delete temp.\cb1 \uc0\u8232 \cb3 When you display the stack element, First Check for Stack Empty as in pop operation. If it is not empty, Display all the elements of current stack starting from top to First.\cb1 \
\pard\pardeftab720\sl220\sa200\partightenfactor0
\cf4 \cb3 \strokec4 #include <stdio.h>\cb1 \uc0\u8232 \cb3 #include <stdlib.h>\
\pard\pardeftab720\sl120\partightenfactor0

\fs22 \cf2 \cb1 \strokec2 \
\pard\pardeftab720\sl220\sa200\partightenfactor0

\fs20 \cf2 \cb3 struct node\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 int info;\cb1 \uc0\u8232 \cb3 struct node *ptr;\cb1 \uc0\u8232 \cb3 \}*top,*top1,*temp;\cb1 \
\cb3 int topelement();\cb1 \uc0\u8232 \cb3 void push(int data);\cb1 \uc0\u8232 \cb3 void pop();\cb1 \uc0\u8232 \cb3 void empty();\cb1 \uc0\u8232 \cb3 void display();\cb1 \uc0\u8232 \cb3 void destroy();\cb1 \uc0\u8232 \cb3 void stack_count();\cb1 \uc0\u8232 \cb3 void create();\cb1 \
\cb3 int count = 0;\cb1 \
\cb3 void main()\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 int no, ch, e;\cb1 \
\cb3 printf("\\n 1 - Push");\cb1 \uc0\u8232 \cb3 printf("\\n 2 - Pop");\cb1 \uc0\u8232 \cb3 printf("\\n 3 - Top");\cb1 \uc0\u8232 \cb3 printf("\\n 4 - Empty");\cb1 \uc0\u8232 \cb3 printf("\\n 5 - Exit");\cb1 \uc0\u8232 \cb3 printf("\\n 6 - Dipslay");\cb1 \uc0\u8232 \cb3 printf("\\n 7 - Stack Count");\cb1 \uc0\u8232 \cb3 printf("\\n 8 - Destroy stack");\cb1 \
\cb3 create();\cb1 \
\cb3 while (1)\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 printf("\\n Enter choice : ");\cb1 \uc0\u8232 \cb3 scanf("%d", &ch);\cb1 \
\cb3 switch (ch)\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 case 1:\cb1 \uc0\u8232 \cb3 printf("Enter data : ");\cb1 \uc0\u8232 \cb3 scanf("%d", &no);\cb1 \uc0\u8232 \cb3 push(no);\cb1 \uc0\u8232 \cb3 break;\cb1 \uc0\u8232 \cb3 case 2:\cb1 \uc0\u8232 \cb3 pop();\cb1 \uc0\u8232 \cb3 break;\cb1 \uc0\u8232 \cb3 case 3:\cb1 \uc0\u8232 \cb3 if (top == NULL)\cb1 \uc0\u8232 \cb3 printf("No elements in stack");\cb1 \uc0\u8232 \cb3 else\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 e = topelement();\cb1 \uc0\u8232 \cb3 printf("\\n Top element : %d", e);\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 break;\cb1 \uc0\u8232 \cb3 case 4:\cb1 \uc0\u8232 \cb3 empty();\cb1 \uc0\u8232 \cb3 break;\cb1 \uc0\u8232 \cb3 case 5:\cb1 \uc0\u8232 \cb3 exit(0);\cb1 \uc0\u8232 \cb3 case 6:\cb1 \uc0\u8232 \cb3 display();\cb1 \uc0\u8232 \cb3 break;\cb1 \uc0\u8232 \cb3 case 7:\cb1 \uc0\u8232 \cb3 stack_count();\cb1 \uc0\u8232 \cb3 break;\cb1 \uc0\u8232 \cb3 case 8:\cb1 \uc0\u8232 \cb3 destroy();\cb1 \uc0\u8232 \cb3 break;\cb1 \uc0\u8232 \cb3 default :\cb1 \uc0\u8232 \cb3 printf(" Wrong choice, Please enter correct choice ");\cb1 \uc0\u8232 \cb3 break;\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 \}\cb1 \
\cb3 /* Create empty stack */\cb1 \uc0\u8232 \cb3 void create()\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 top = NULL;\cb1 \uc0\u8232 \cb3 \}\cb1 \
\cb3 /* Count stack elements */\cb1 \uc0\u8232 \cb3 void stack_count()\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 printf("\\n No. of elements in stack : %d", count);\cb1 \uc0\u8232 \cb3 \}\cb1 \
\cb3 /* Push data into stack */\cb1 \uc0\u8232 \cb3 void push(int data)\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 if (top == NULL)\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 top =(struct node )malloc(1sizeof(struct node));\cb1 \uc0\u8232 \cb3 top->ptr = NULL;\cb1 \uc0\u8232 \cb3 top->info = data;\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 else\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 temp =(struct node )malloc(1sizeof(struct node));\cb1 \uc0\u8232 \cb3 temp->ptr = top;\cb1 \uc0\u8232 \cb3 temp->info = data;\cb1 \uc0\u8232 \cb3 top = temp;\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 count++;\cb1 \uc0\u8232 \cb3 \}\cb1 \
\cb3 /* Display stack elements */\cb1 \uc0\u8232 \cb3 void display()\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 top1 = top;\cb1 \
\cb3 if (top1 == NULL)\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 printf("Stack is empty");\cb1 \uc0\u8232 \cb3 return;\cb1 \uc0\u8232 \cb3 \}\cb1 \
\cb3 while (top1 != NULL)\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 printf("%d ", top1->info);\cb1 \uc0\u8232 \cb3 top1 = top1->ptr;\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 \}\cb1 \
\cb3 /* Pop Operation on stack */\cb1 \uc0\u8232 \cb3 void pop()\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 top1 = top;\cb1 \
\cb3 if (top1 == NULL)\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 printf("\\n Error : Trying to pop from empty stack");\cb1 \uc0\u8232 \cb3 return;\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 else\cb1 \uc0\u8232 \cb3 top1 = top1->ptr;\cb1 \uc0\u8232 \cb3 printf("\\n Popped value : %d", top->info);\cb1 \uc0\u8232 \cb3 free(top);\cb1 \uc0\u8232 \cb3 top = top1;\cb1 \uc0\u8232 \cb3 count--;\cb1 \uc0\u8232 \cb3 \}\cb1 \
\cb3 /* Return top element */\cb1 \uc0\u8232 \cb3 int topelement()\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 return(top->info);\cb1 \uc0\u8232 \cb3 \}\cb1 \
\cb3 /* Check if stack is empty or not */\cb1 \uc0\u8232 \cb3 void empty()\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 if (top == NULL)\cb1 \uc0\u8232 \cb3 printf("\\n Stack is empty");\cb1 \uc0\u8232 \cb3 else\cb1 \uc0\u8232 \cb3 printf("\\n Stack is not empty with %d elements", count);\cb1 \uc0\u8232 \cb3 \}\cb1 \
\cb3 /* Destroy entire stack */\cb1 \uc0\u8232 \cb3 void destroy()\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 top1 = top;\cb1 \
\cb3 while (top1 != NULL)\cb1 \uc0\u8232 \cb3 \{\cb1 \uc0\u8232 \cb3 top1 = top->ptr;\cb1 \uc0\u8232 \cb3 free(top);\cb1 \uc0\u8232 \cb3 top = top1;\cb1 \uc0\u8232 \cb3 top1 = top1->ptr;\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 free(top1);\cb1 \uc0\u8232 \cb3 top = NULL;\cb1 \
\cb3 printf("\\n All stack elements destroyed");\cb1 \uc0\u8232 \cb3 count = 0;\cb1 \
}